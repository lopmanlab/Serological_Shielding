#log_like = dnbinom(y, psi, mu=rho*v.D_model, log=TRUE) ## negative binomial regression with an improper uninform prior
#log_like = dpois(x=y, lambda = v.D_model, log=TRUE)
# These should be rates
dDm.dt = v.D_model[2:length(v.D_model)] - v.D_model[1:(length(v.D_model)-1)]
dDo.dt = y[2:length(y)] - y[1:(length(y)-1)]
log_like = dpois(x=dDo.dt, lambda = dDm.dt, log=TRUE)
#print(dDm.dt)
#print(dDo.dt)
print(sum(log_like))
return(sum(log_like))
}
# # (2) Run MCMC ------------------------------------------------------------
post.samp = MCMCmetrop1R(seir_err
, theta.init=th_init
, y=v.obs
, X=X0
, mcmc=5000
, burnin=1000
, verbose=100
#, optim.method = 'L-BFGS-B'
#, optim.lower = c(-3, -1, -2, -4)
#, optim.upper = c(3, 1, 2, 4)
#, optim.control = list(ndeps=c(.1,.1,.1,.1))
, force.samp=TRUE
, logfun=TRUE
, seed=list(NA,1))
post.samp.out = sweep(plogis(post.samp), 2, (th_max-th_min), "*")
post.samp.out.tail= tail(post.samp.out, 1200)
df.post_samp = data.frame(post.samp.out.tail)
post.samp.optimal_parameters = apply(df.post_samp, 2, function(df_in){
i_y=which.max(density(df_in)$y)
x=density(df_in)$x[i_y]
return(x)
})
plot(post.samp.out)
th_init = th_opts
th_min = c(0, 0, 0, 0, 0)
th_max = c(1, 1, 1, 60, 1)
# Logit-Transform
th_init = qlogis(th_init/(th_max-th_min))
# (1) Define Likelihood ---------------------------------------------------
seir_err = function(theta, y, X, Pars = pars_nyc_reduced_in){
print(theta)
# Un-transform
th_norm = plogis(theta)
th_ori = th_norm*(th_max-th_min)
print(th_ori)
# Load Parms
Pars_in = Pars
v.D_observed = y
# Set relevant parameters to th_ori
Pars_in[['q']] = th_ori[1]                        # Constrianed [0,0.1]
Pars_in[['c']] = th_ori[2]                        # Constrianed [0,0.1]
Pars_in[['p_symptomatic']] = th_ori[3]
Pars_in[['socialDistancing_other']] = th_ori[5]
Pars_in[['p_reduced']] = th_ori[5]
# Timeshift
# - just means run the simulation for the shift, and use that as the new X0
# - at least 10 timesteps /w increments of 0.1
if(th_ori[4]){
if(th_ori[4]<1){
time_shift = 1:10*(th_ori[4]/10)
}else if(th_ori[4]<10){
temp_t = floor(th_ori[4]*10)
time_shift = c((1:temp_t)/10, th_ori[4])
}else{
temp_t = floor(th_ori[4])
time_shift = c((1:temp_t), th_ori[4])
}
model_shift = ode(y = X
, times = time_shift
, fun = seir_model_shields_reduced
, parms = Pars_in
, method = 'ode45')
X0_shift = model_shift[nrow(model_shift),-1]
}else{
X0_shift = X
}
# Run with shift
model_out = ode(y = X0_shift
, times = Pars_in$times
, fun = seir_model_shields_reduced
, parms = Pars_in
, method = 'ode45')
model_out = as.data.frame(model_out)[,-1] # remove the time column
# Cumulative Cases
v.D_model_byDay = rowSums(model_out[, Pars_in$D_ids])
v.D_model_byWeek = v.D_model_byDay[1:(length(v.D_model_byDay)/7)*7]
# Aggregate by week
v.D_model = v.D_model_byWeek
# Calculate the log likelihood of the observed new case rates compared to the model rates
#log_like = dnbinom(y, psi, mu=rho*v.D_model, log=TRUE) ## negative binomial regression with an improper uninform prior
#log_like = dpois(x=y, lambda = v.D_model, log=TRUE)
# These should be rates
dDm.dt = v.D_model[2:length(v.D_model)] - v.D_model[1:(length(v.D_model)-1)]
dDo.dt = y[2:length(y)] - y[1:(length(y)-1)]
log_like = dpois(x=dDo.dt, lambda = dDm.dt, log=TRUE)
#print(dDm.dt)
#print(dDo.dt)
print(sum(log_like))
return(sum(log_like))
}
# # (2) Run MCMC ------------------------------------------------------------
post.samp = MCMCmetrop1R(seir_err
, theta.init=th_init
, y=v.obs
, X=X0
, mcmc=5000
, burnin=1000
, verbose=100
#, optim.method = 'L-BFGS-B'
#, optim.lower = c(-3, -1, -2, -4)
#, optim.upper = c(3, 1, 2, 4)
#, optim.control = list(ndeps=c(.1,.1,.1,.1))
, force.samp=TRUE
, logfun=TRUE
, seed=list(NA,1))
post.samp.out = sweep(plogis(post.samp), 2, (th_max-th_min), "*")
post.samp.out.tail= tail(post.samp.out, 1200)
plot(post.samp.out)
plot(post.samp)
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/test_mcmcmetrop1r_reduced.R')
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_default.R')
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_default.R')
pars_default
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_reduced.R')
pars_default
model_pars_reduced
pars_reduced_default
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_reduced.R')
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_reduced.R')
X0
X
X = Get_Inits(pars_reduced_default)
X
seir_model_shields_reduced = function(t, X, Pars) {
# Core transmission model
#   - Subscripts are defined as follows: c=children, a=non-essential adults,
#     rc=reduced contact adults, fc=full contact adults, e=elderly
#   - For infection equations: The I compartments correspond to infectious
#     periods, not periods in which people are symptomatic
#   - Is are cases that are severe enough to be documented eventually and Ia are undocumented cases
#   - Since we are not fitting to data we do not need to model specifically when the cases are documented
#   - _pos indicates people who have tested positive for COVID-19 by antibody test
test.switch1<-sw1fxn(t)
test.switch2<-sw2fxn(t)
# (0) Setup ---------------------------------------------------------------
# Load all pars
for(i_par in 1:length(Pars)){
assign(names(Pars)[i_par], Pars[[i_par]])
}
# Update Pars
socialDistancing_other_c = 1-(0.75*c)
p_reduced_c = 1-(0.9*c)
# Load all Vars
for(i_var in 1:length(X)){
assign(names(X)[i_var], X[[i_var]])
}
# Load in Matrix Form
mat_X = Vec_to_Mat(X, Subgroups=subgroups, Compartments=compartments)
# Number of infections at time t for each subgroup
infec = asymp_red*mat_X[,'Iasym'] + mat_X[,'Isym']
# Population sizes/testing status at time t
tot = rowSums(mat_X[,colnames(mat_X)!='D'])
#Fraction of population in each group who has tested positive by time
frac_released = 0
frac_distanced = rep(1,5)
frac_comb = as.vector(rbind(frac_released, frac_distanced)) # interleaved
# (1) Derive Contact Matrices ---------------------------------------------
#Change matrices used over time
if(t<tStart_distancing | t>=tStart_reopen){ #Use baseline matrices until social distancing starts
CM = HomeContacts_5x5 +
SchoolContacts_5x5 +
WorkContacts_5x5 +
OtherContacts_5x5
}
if(t>=tStart_distancing & t<tStart_reopen){
# if(t>=tStart_distancing & t<tStart_target){ #Use these matrices under general social distancing without testing
CM = HomeContacts_5x5 +
WorkContacts_Distancing_5x5 +
OtherContacts_Distancing_5x5
}
# (3) Calculate v.fois ------------------------------------------------------
# Force of infection by group
temp.I = infec/tot
temp.I = t(t(CM)*temp.I)*q
v.fois = rowSums(temp.I)
names(v.fois) = c('foi_c_gen','foi_a_gen', 'foi_rc_gen', 'foi_fc_gen', 'foi_e_gen')
# (4) Sero Testing --------------------------------------------------------
# NONE
# (5) Model Equations -----------------------------------------------------
dS = -v.fois*mat_X[,'S'] -
(1-specificity)*test.switch2*1*mat_X[,'S']
dE = v.fois*mat_X[,'S'] -
gamma_e*mat_X[,'E'] -
(1-specificity)*test.switch2*1*mat_X[,'E']
dIsym = p_symptomatic*gamma_e*mat_X[,'E'] -
gamma_s*mat_X[,'Isym']
dIasym = (1-p_symptomatic)*gamma_e*mat_X[,'E'] -
gamma_a*mat_X[,'Iasym'] -
(1-specificity)*test.switch2*1*mat_X[,'Iasym']
dHsub = gamma_s*(hosp_frac_5-hosp_crit_5)*mat_X[,'Isym'] -
gamma_hs*mat_X[,'Hsub']
dHcri = gamma_s*hosp_crit_5*mat_X[,'Isym'] -
gamma_hc*mat_X[,'Hcri']
dD = gamma_hc*crit_die_5*mat_X[,'Hcri']
dR = gamma_s*(1-hosp_frac_5)*mat_X[,'Isym'] +
gamma_a*mat_X[,'Iasym'] +
(1-sensitivity)*test.switch2*gamma_hs*mat_X[,'Hsub'] +
(1-sensitivity)*test.switch2*gamma_hc*(1-crit_die_5)*mat_X[,'Hcri'] -
sensitivity*test.switch2*1*mat_X[,'R'] +
gamma_hc*test.switch1*(1-crit_die_5)*mat_X[,'Hcri'] +
gamma_hs*test.switch1*mat_X[,'Hsub']
res = c(dS, dE, dIsym, dIasym, dHsub, dHcri, dD, dR)
names(res) = varNames
return(list(res))
}
X = Get_Inits(pars_reduced_default)
seir_model_shields_reduced(0, X, pars_reduced_default)
seir_model_shields_reduced = function(t, X, Pars) {
# Core transmission model
#   - Subscripts are defined as follows: c=children, a=non-essential adults,
#     rc=reduced contact adults, fc=full contact adults, e=elderly
#   - For infection equations: The I compartments correspond to infectious
#     periods, not periods in which people are symptomatic
#   - Is are cases that are severe enough to be documented eventually and Ia are undocumented cases
#   - Since we are not fitting to data we do not need to model specifically when the cases are documented
#   - _pos indicates people who have tested positive for COVID-19 by antibody test
test.switch1<-sw1fxn(t)
test.switch2<-sw2fxn(t)
# (0) Setup ---------------------------------------------------------------
# Load all pars
for(i_par in 1:length(Pars)){
assign(names(Pars)[i_par], Pars[[i_par]])
}
# Update Pars
socialDistancing_other_c = 1-(0.75*c)
p_reduced_c = 1-(0.9*c)
# Load all Vars
for(i_var in 1:length(X)){
assign(names(X)[i_var], X[[i_var]])
}
# Load in Matrix Form
mat_X = Vec_to_Mat(X, Subgroups=subgroups, Compartments=compartments)
# Number of infections at time t for each subgroup
infec = asymp_red*mat_X[,'Iasym'] + mat_X[,'Isym']
# Population sizes/testing status at time t
tot = rowSums(mat_X[,colnames(mat_X)!='D'])
#Fraction of population in each group who has tested positive by time
frac_released = 0
frac_distanced = rep(1,5)
frac_comb = as.vector(rbind(frac_released, frac_distanced)) # interleaved
# (1) Derive Contact Matrices ---------------------------------------------
#Change matrices used over time
if(t<tStart_distancing | t>=tStart_reopen){ #Use baseline matrices until social distancing starts
CM = HomeContacts_5x5 +
SchoolContacts_5x5 +
WorkContacts_5x5 +
OtherContacts_5x5
}
if(t>=tStart_distancing & t<tStart_reopen){
# if(t>=tStart_distancing & t<tStart_target){ #Use these matrices under general social distancing without testing
CM = HomeContacts_5x5 +
WorkContacts_Distancing_5x5 +
OtherContacts_Distancing_5x5
}
# (3) Calculate v.fois ------------------------------------------------------
# Force of infection by group
temp.I = infec/tot
temp.I = t(t(CM)*temp.I)*q
v.fois = rowSums(temp.I)
names(v.fois) = c('foi_c_gen','foi_a_gen', 'foi_rc_gen', 'foi_fc_gen', 'foi_e_gen')
print(v.fois)
# (4) Sero Testing --------------------------------------------------------
# NONE
# (5) Model Equations -----------------------------------------------------
dS = -v.fois*mat_X[,'S'] -
(1-specificity)*test.switch2*1*mat_X[,'S']
dE = v.fois*mat_X[,'S'] -
gamma_e*mat_X[,'E'] -
(1-specificity)*test.switch2*1*mat_X[,'E']
dIsym = p_symptomatic*gamma_e*mat_X[,'E'] -
gamma_s*mat_X[,'Isym']
dIasym = (1-p_symptomatic)*gamma_e*mat_X[,'E'] -
gamma_a*mat_X[,'Iasym'] -
(1-specificity)*test.switch2*1*mat_X[,'Iasym']
dHsub = gamma_s*(hosp_frac_5-hosp_crit_5)*mat_X[,'Isym'] -
gamma_hs*mat_X[,'Hsub']
dHcri = gamma_s*hosp_crit_5*mat_X[,'Isym'] -
gamma_hc*mat_X[,'Hcri']
dD = gamma_hc*crit_die_5*mat_X[,'Hcri']
dR = gamma_s*(1-hosp_frac_5)*mat_X[,'Isym'] +
gamma_a*mat_X[,'Iasym'] +
(1-sensitivity)*test.switch2*gamma_hs*mat_X[,'Hsub'] +
(1-sensitivity)*test.switch2*gamma_hc*(1-crit_die_5)*mat_X[,'Hcri'] -
sensitivity*test.switch2*1*mat_X[,'R'] +
gamma_hc*test.switch1*(1-crit_die_5)*mat_X[,'Hcri'] +
gamma_hs*test.switch1*mat_X[,'Hsub']
res = c(dS, dE, dIsym, dIasym, dHsub, dHcri, dD, dR)
names(res) = varNames
return(list(res))
}
X = Get_Inits(pars_reduced_default)
seir_model_shields_reduced(0, X, pars_reduced_default)
seir_model_shields_reduced = function(t, X, Pars) {
# Core transmission model
#   - Subscripts are defined as follows: c=children, a=non-essential adults,
#     rc=reduced contact adults, fc=full contact adults, e=elderly
#   - For infection equations: The I compartments correspond to infectious
#     periods, not periods in which people are symptomatic
#   - Is are cases that are severe enough to be documented eventually and Ia are undocumented cases
#   - Since we are not fitting to data we do not need to model specifically when the cases are documented
#   - _pos indicates people who have tested positive for COVID-19 by antibody test
test.switch1<-sw1fxn(t)
test.switch2<-sw2fxn(t)
# (0) Setup ---------------------------------------------------------------
# Load all pars
for(i_par in 1:length(Pars)){
assign(names(Pars)[i_par], Pars[[i_par]])
}
# Update Pars
socialDistancing_other_c = 1-(0.75*c)
p_reduced_c = 1-(0.9*c)
# Load all Vars
for(i_var in 1:length(X)){
assign(names(X)[i_var], X[[i_var]])
}
# Load in Matrix Form
mat_X = Vec_to_Mat(X, Subgroups=subgroups, Compartments=compartments)
# Number of infections at time t for each subgroup
infec = asymp_red*mat_X[,'Iasym'] + mat_X[,'Isym']
# Population sizes/testing status at time t
tot = rowSums(mat_X[,colnames(mat_X)!='D'])
#Fraction of population in each group who has tested positive by time
frac_released = 0
frac_distanced = rep(1,5)
frac_comb = as.vector(rbind(frac_released, frac_distanced)) # interleaved
# (1) Derive Contact Matrices ---------------------------------------------
#Change matrices used over time
if(t<tStart_distancing | t>=tStart_reopen){ #Use baseline matrices until social distancing starts
CM = HomeContacts_5x5 +
SchoolContacts_5x5 +
WorkContacts_5x5 +
OtherContacts_5x5
}
if(t>=tStart_distancing & t<tStart_reopen){
# if(t>=tStart_distancing & t<tStart_target){ #Use these matrices under general social distancing without testing
CM = HomeContacts_5x5 +
WorkContacts_Distancing_5x5 +
OtherContacts_Distancing_5x5
}
# (3) Calculate v.fois ------------------------------------------------------
# Force of infection by group
temp.I = infec/tot
temp.I = t(t(CM)*temp.I)*q
v.fois = rowSums(temp.I)
names(v.fois) = c('foi_c_gen','foi_a_gen', 'foi_rc_gen', 'foi_fc_gen', 'foi_e_gen')
print(temp.I)
print(v.fois)
# (4) Sero Testing --------------------------------------------------------
# NONE
# (5) Model Equations -----------------------------------------------------
dS = -v.fois*mat_X[,'S'] -
(1-specificity)*test.switch2*1*mat_X[,'S']
dE = v.fois*mat_X[,'S'] -
gamma_e*mat_X[,'E'] -
(1-specificity)*test.switch2*1*mat_X[,'E']
dIsym = p_symptomatic*gamma_e*mat_X[,'E'] -
gamma_s*mat_X[,'Isym']
dIasym = (1-p_symptomatic)*gamma_e*mat_X[,'E'] -
gamma_a*mat_X[,'Iasym'] -
(1-specificity)*test.switch2*1*mat_X[,'Iasym']
dHsub = gamma_s*(hosp_frac_5-hosp_crit_5)*mat_X[,'Isym'] -
gamma_hs*mat_X[,'Hsub']
dHcri = gamma_s*hosp_crit_5*mat_X[,'Isym'] -
gamma_hc*mat_X[,'Hcri']
dD = gamma_hc*crit_die_5*mat_X[,'Hcri']
dR = gamma_s*(1-hosp_frac_5)*mat_X[,'Isym'] +
gamma_a*mat_X[,'Iasym'] +
(1-sensitivity)*test.switch2*gamma_hs*mat_X[,'Hsub'] +
(1-sensitivity)*test.switch2*gamma_hc*(1-crit_die_5)*mat_X[,'Hcri'] -
sensitivity*test.switch2*1*mat_X[,'R'] +
gamma_hc*test.switch1*(1-crit_die_5)*mat_X[,'Hcri'] +
gamma_hs*test.switch1*mat_X[,'Hsub']
res = c(dS, dE, dIsym, dIasym, dHsub, dHcri, dD, dR)
names(res) = varNames
return(list(res))
}
X = Get_Inits(pars_reduced_default)
seir_model_shields_reduced(0, X, pars_reduced_default)
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/temp reduecd.R')
sw1fxn(1)
sw1fxn(1:100)
sw1fxn(1:365
)
sw1fxn((1:3650)/10)
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/utils.R')
X = Get_Inits(pars_reduced_default)
seir_model_shields_reduced(0, X, pars_reduced_default)
test.switch2
sw2fxn(1)
sw2fxn(2)
pars_reduced_default$WorkContacts_Distancing_5x5
temp.firstCase
source('~/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_fits.R')
as.Date(df.SAH['tStart_distancing', 'nyc'])
require('readxl')
source('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_default.R')
source('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_reduced.R')
# (0) Load Data -----------------------------------------------------------
# SAH orders
temp.SAH = read_xlsx('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/Deaths data/SAH orders by location.xlsx')
df.SAH = data.frame('wash' = c('2020-03-16', '2020-05-31')
, 'nyc' = c('2020-03-16', '2020-06-08')
, 'miami' = c('2020-03-17', '2020-05-20')
, 'miss' = c('2020-04-06', '2020-05-03')
, 'utah' = c('2020-03-17', '2020-05-01')
, 'conn' = c('2020-03-23', '2020-05-20'))
rownames(df.SAH) = c('tStart_distancing', 'tStop_distancing')
# Age structure
temp.age = read_xlsx('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/Deaths data/AgeStructure_byLocation.xlsx')
# New York Times Cases
temp.states = read.csv('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/07_29_2020_NYT_us-states.csv')
# NYC ---------------------------------------------------------------------
df.nyc = temp.states[temp.states$state == 'New York',]
temp.firstCase = '2020-03-01' # taken from NYT database
# Parse NYC death Data
#temp.nyc_Deaths = df.nyc[,c('date', 'deaths')]
temp.nyc_Deaths = read.csv('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/Deaths data/nyc.csv')
colnames(temp.nyc_Deaths)[2]='date'
temp.days_since_p0 = as.numeric(as.Date(temp.nyc_Deaths[,'date']) - as.Date(temp.firstCase))
temp.day_offset = min(temp.days_since_p0[which(temp.days_since_p0>0)])
temp.nyc_Deaths$wk = (temp.days_since_p0 - temp.day_offset)/7+1
temp.nyc_Deaths = temp.nyc_Deaths[temp.nyc_Deaths$wk>0,]
v.nyc = rep(0, max(temp.nyc_Deaths$wk))
v.nyc[temp.nyc_Deaths$wk] = temp.nyc_Deaths$wkdeaths
# Create pars for NYC
pars_nyc = list()
pars_nyc[['N']] = sum(temp.age[temp.age$Location=='NYC',4])
pars_nyc[['agefrac.0']] = NULL
pars_nyc[['agestruc']] = (as.vector(unlist(temp.age[temp.age$Location=='NYC',3])))
# Days
pars_nyc[['t0']] = temp.firstCase
pars_nyc[['nDays']] = max(temp.nyc_Deaths$wk)*7
pars_nyc[['times']] = 1:pars_nyc$nDays
# Only intervention is social distancing
pars_nyc[['daily_tests']] = 0
pars_nyc[['tStart_distancing']] = as.numeric(1+(as.Date(df.SAH['tStart_distancing', 'nyc'])-as.Date(temp.firstCase)))
as.Date(df.SAH['tStart_distancing', 'nyc'])
as.Date(df.SAH['tStop_distancing', 'nyc'])
pars_nyc[['tStart_distancing']]
.pars_nyc[['tStart_reopen']]
pars_nyc[['tStart_reopen']]
pars_nyc[['tStart_reopen']] = as.numeric(1+(as.Date(df.SAH['tStop_distancing', 'nyc'])-as.Date(temp.firstCase)))
pars_nyc[['tStart_reopen']]
100-16
139-55
dpois(0,0,log=TRUE)
dpois(1,0,log=TRUE)
dpois(0,698,log=TRUE)
dpois(698,0,log=TRUE)
dpois(23, 32)
dpois(23, 0)
v.obs
v.obs_rate
require('readxl')
source('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_default.R')
source('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/Lopman Covid SeroPos/Serological_Shielding/CYZ_reorg/R/input_reduced.R')
# (0) Load Data -----------------------------------------------------------
# SAH orders
temp.SAH = read_xlsx('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/Deaths data/SAH orders by location.xlsx')
df.SAH = data.frame('wash' = c('2020-03-16', '2020-05-31')
, 'nyc' = c('2020-03-16', '2020-06-08')
, 'miami' = c('2020-03-17', '2020-05-20')
, 'miss' = c('2020-04-06', '2020-05-03')
, 'utah' = c('2020-03-17', '2020-05-01')
, 'conn' = c('2020-03-23', '2020-05-20'))
rownames(df.SAH) = c('tStart_distancing', 'tStop_distancing')
# Age structure
temp.age = read_xlsx('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/Deaths data/AgeStructure_byLocation.xlsx')
# New York Times Cases
temp.states = read.csv('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/07_29_2020_NYT_us-states.csv')
# NYC ---------------------------------------------------------------------
df.nyc = temp.states[temp.states$state == 'New York',]
temp.firstCase = '2020-03-01' # taken from NYT database
# Parse NYC death Data
#temp.nyc_Deaths = df.nyc[,c('date', 'deaths')]
temp.nyc_Deaths = read.csv('C:/Users/czhao/Documents/CYZ GITHUB/Weitz Group/COVID-19/SERO_DATA/Deaths data/nyc.csv')
colnames(temp.nyc_Deaths)[2]='date'
temp.days_since_p0 = as.numeric(as.Date(temp.nyc_Deaths[,'date']) - as.Date(temp.firstCase))
temp.day_offset = min(temp.days_since_p0[which(temp.days_since_p0>0)])
temp.nyc_Deaths$wk = (temp.days_since_p0 - temp.day_offset)/7+1
temp.nyc_Deaths = temp.nyc_Deaths[temp.nyc_Deaths$wk>0,]
v.nyc = rep(0, max(temp.nyc_Deaths$wk))
v.nyc[temp.nyc_Deaths$wk] = temp.nyc_Deaths$wkdeaths
# Create pars for NYC
pars_nyc = list()
pars_nyc[['N']] = sum(temp.age[temp.age$Location=='NYC',4])
pars_nyc[['agefrac.0']] = NULL
pars_nyc[['agestruc']] = (as.vector(unlist(temp.age[temp.age$Location=='NYC',3])))
# Days
pars_nyc[['t0']] = temp.firstCase
pars_nyc[['nDays']] = max(temp.nyc_Deaths$wk)*7
pars_nyc[['times']] = 1:pars_nyc$nDays
# Only intervention is social distancing
pars_nyc[['daily_tests']] = 0
pars_nyc[['tStart_distancing']] = as.numeric(1+(as.Date(df.SAH['tStart_distancing', 'nyc'])-as.Date(temp.firstCase)))
pars_nyc[['tStart_test']] = 500
pars_nyc[['tStart_target']] = 500 #as.numeric(1+(as.Date(df.SAH['tStart_distancing', 'nyc'])-as.Date(temp.firstCase)))
pars_nyc[['tStart_school']] = 500 #as.numeric(1+(as.Date(df.SAH['tStart_distancing', 'nyc'])-as.Date(temp.firstCase)))
pars_nyc[['tStart_reopen']] = as.numeric(1+(as.Date(df.SAH['tStop_distancing', 'nyc'])-as.Date(temp.firstCase)))
df.SAH
